#
# Board configuration file for the Metrotek SmartSFP
#
# This board does not have an embedded JTAG adapter, you must source
# a suitable adapter configuration before sourcing this file.

# SmartSFP has a standard ARM-20 JTAG connector with
# nTRST and nSRST available.
reset_config trst_and_srst srst_pulls_trst srst_gates_jtag trst_open_drain srst_open_drain

# the only possible transport is JTAG
transport select jtag

# iMX6S POR gates JTAG and the chip is completely incommunicado
# over JTAG for at least 10ms after nSRST is deasserted
adapter_nsrst_delay 11

jtag_ntrst_delay 1000

# Tell imx6.cfg that we have iMX6S rev 1.1
# and System JTAG Controller have specific JTAG IDCODE
#
# i.MX 6Solo/6DualLite Applications Processor Reference Manual, Rev. 3, 09/2017
# https://www.nxp.com/docs/en/reference-manual/IMX6SDLRM.pdf
# page 363, 7.2.3.2 JTAG ID, Table 7-1. i.MX JTAG ID
set CHIPNAME imx6ull 
set DAP_TAPID 0x5ba00477
set SJC_TAPID 0x088c101d

# Source generic iMX6 target configuration
source [find target/imx6ull.cfg]

# function to apply initial configuration after a reset. It
# provides a basic pad configuration and also DDR memory and clocks
# sufficient to load and execute a boot loader (e.g. u-boot) from
# DDR memory. This list is extracted from the u-boot flash image
# header.
proc apply_dcd { } {

   puts "Applying DCD..."

   halt
   dap apcsw 1

	mww phys 0x020c4068 0xffffffff
	mww phys 0x020c406c 0xffffffff
	mww phys 0x020c4070 0xffffffff
	mww phys 0x020c4074 0xffffffff
	mww phys 0x020c4078 0xffffffff
	mww phys 0x020c407c 0xffffffff
	mww phys 0x020c4080 0xffffffff

#DDR IO TYPE:			
	mww phys 0x020e04b4 0x000C0000	
	mww phys 0x020e04ac 0x00000000	
			
#CLOCK:			
	mww phys 0x020e027c 0x00000030	
			
#ADDRESS:			
	mww phys 0x020e0250 0x00000030	
	mww phys 0x020e024c 0x00000030	
	mww phys 0x020e0490 0x00000030	
			
#Control:			
	mww phys 0x020e0288 0x000C0030	
	mww phys 0x020e0270 0x00000000	
	mww phys 0x020e0260 0x00000030	
	mww phys 0x020e0264 0x00000030	
	mww phys 0x020e04a0 0x00000030	
			
#Data Strobes:			
	mww phys 0x020e0494 0x00020000	
	mww phys 0x020e0280 0x00000030	
	mww phys 0x020e0284 0x00000030	
			
#Data:			
	mww phys 0x020e04b0 0x00020000	
	mww phys 0x020e0498 0x00000030	
	mww phys 0x020e04a4 0x00000030	
			
	mww phys 0x020e0244 0x00000030	
	mww phys 0x020e0248 0x00000030	

	mww phys 0x021b001c 0x00008000	
			
#=============================================================================			
# Calibration setup.			
#=============================================================================			
	mww phys 0x021b0800 0xA1390003
			
# For target board, may need to run write leveling calibration to fine tune these settings.			
	mww phys 0x021b080c  0x00000004	
			
#Read DQS Gating calibration			
	mww phys 0x021b083c 0x00000000	
			
#Read calibration			
	mww phys 0x021b0848 0x40404040	
			
#Write calibration                     			
	mww phys 0x021b0850 0x40404040	
			
#read data bit delay: (3 is the reccommended default value, although out of reset value is 0)			
	mww phys 0x021b081c 0x33333333	
	mww phys 0x021b0820 0x33333333	
			
#write data bit delay: 			
	mww phys 0x021b082c 0xF3333333	
	mww phys 0x021b0830 0xF3333333	
			
#DQS&CLK Duty Cycle			
	mww phys 0x021b08c0 0x00944009
			
# Complete calibration by forced measurement:                  			
	mww phys 0x021b08b8 0x00000800
#=============================================================================			
# Calibration setup end			
#=============================================================================			
			
#MMDC init: 			
	mww phys 0x021b0004 0x0002002D	
	mww phys 0x021b0008 0x1B333030	
	mww phys 0x021b000c 0x676B52F3	
	mww phys 0x021b0010 0xB66D0B63	
	mww phys 0x021b0014 0x01FF00DB	
			
#MDMISC: RALAT kept to the high level of 5. 			
#MDMISC: consider reducing RALAT if your 528MHz board design allow that. Lower RALAT benefits: 			
#a. better operation at low frequency, for LPDDR2 freq < 100MHz, change RALAT to 3			
#b. Small performence improvment 			
	mww phys 0x021b0018 0x00211740	
	mww phys 0x021b001c 0x00008000	
	mww phys 0x021b002c 0x000026D2	
	mww phys 0x021b0030 0x006B1023	
	mww phys 0x021b0040 0x0000004F
	mww phys 0x021b0000 0x84180000	
			
	mww phys 0x021b0890 0x00400000	
			
#Mode register writes                 			
	mww phys 0x021b001c 0x02008032	
	mww phys 0x021b001c 0x00008033	
	mww phys 0x021b001c 0x00048031	
	mww phys 0x021b001c 0x15208030	
	mww phys 0x021b001c 0x04008040	
			
#	mww phys 0x021b001c 0x0200803A	
#	mww phys 0x021b001c 0x0000803B	
#	mww phys 0x021b001c 0x00048039	
#	mww phys 0x021b001c 0x15208038	
#	mww phys 0x021b001c 0x04008048	
			
	mww phys 0x021b0020 0x00007800	
			
	mww phys 0x021b0818 0x00000227
			
	mww phys 0x021b0004 0x0002552D	
			
	mww phys 0x021b0404 0x00011006	
			
	mww phys 0x021b001c 0x00000000	

	puts "DCD applyed."
}

# disable watchdog
proc disable_wdog { } {
   puts "Disabling watchdog..."
	mwh 0x020bc000 0x30
   puts "Watchdog disabled."
}

proc clear_regs {} {
     puts "---->clear_regs---->begin"
     reg r1 0
     reg r2 0
     reg r3 0
     reg r4 0
     reg r5 0
     reg r6 0
     reg r7 0
     reg r8 0
     reg r9 0
     reg r10 0
     reg r11 0
     reg r12 0

     reg pc  0x10800000

     reg cpsr 0x1d3
     arm mcr 15 0 15 2 4 0x70000013
     puts "---->clear_regs---->end"
}

proc imx6_clock_init {} {
   puts "---->init_imx6_clock---->begin"

   # asm/arch-mx6/crm_regs.h
   set CCM_CCGR0               0x020C4068
   set CCM_CCGR1               0x020C406c
   set CCM_CCGR2               0x020C4070
   set CCM_CCGR3               0x020C4074
   set CCM_CCGR4               0x020C4078
   set CCM_CCGR5               0x020C407c
   set CCM_CCGR6               0x020C4080

   # Enable all clocks
   mww phys $CCM_CCGR0 0xFFFFFFFF
   mww phys $CCM_CCGR1 0xFFFFFFFF
   mww phys $CCM_CCGR2 0xFFFFFFFF
   mww phys $CCM_CCGR3 0xFFFFFFFF
   mww phys $CCM_CCGR4 0xFFFFFFFF
   mww phys $CCM_CCGR5 0xFFFFFFFF
   mww phys $CCM_CCGR6 0xFFFFFFFF

#   mww phys $CCM_CCGR0 0x00C03F3F
#   mww phys $CCM_CCGR1 0x0030FC03
#   mww phys $CCM_CCGR2 0x0FFFC000
#   mww phys $CCM_CCGR3 0x3FF00000
#   mww phys $CCM_CCGR4 0x00FFF300
#   mww phys $CCM_CCGR5 0x0F0000C3
#   mww phys $CCM_CCGR6 0x000003FF

   puts "---->init_imx6_clock---->end"
}

proc imx6_cache_init {} {
   puts "---->init_imx6_cache---->begin"

   # asm/arch-mx6/iomux.h
   set MX6_IOMUXC_GPR4         0x020e0010
   set MX6_IOMUXC_GPR6         0x020e0018
   set MX6_IOMUXC_GPR7         0x020e001c

   # asm/arch-mx6/crm_regs.h
   set CCM_CCOSR               0x020c4060

   # enable AXI cache for VDOA/VPU/IPU */
   mww phys $MX6_IOMUXC_GPR4 0xF00000CF
   # set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7
   mww phys $MX6_IOMUXC_GPR6 0x007F007F
   mww phys $MX6_IOMUXC_GPR7 0x007F007F

   #
   # Setup CCM_CCOSR register as follows:
   #
   # cko1_en  = 1     --> CKO1 enabled
   # cko1_div = 111  --> divide by 8
   # cko1_sel = 1011 --> ahb_clk_root
   #
   # This sets CKO1 at ahb_clk_root/8 = 132/8 = 16.5 MHz
   #
   mww phys $CCM_CCOSR 0x000000fb

   puts "---->init_imx6_cache---->end"
}

proc uart1_init {} {
   puts "---->init_imx6_uart1---->begin"


   puts "---->init_imx6_uart1---->end"
}

proc imx6ull_init {} {
   puts "-->init_imx6-->begin"

   halt
   dap apcsw 1

   disable_wdog
   imx6_clock_init
   apply_dcd
   imx6_cache_init

   clear_regs

   puts "-->init_imx6-->end"
}

# prevent cortex-a code from asserting SRST again
$_TARGETNAME configure -event reset-assert { }

$_TARGETNAME configure -event reset-start { adapter_khz 1000 }

# hook the init function into the reset-init event
#$_TARGETNAME configure -event reset-init { imx6ull_init }

# make sure target is halted when gdb attaches
$_TARGETNAME configure -event gdb-attach { halt }

# this is needed if we're going to be running code we've
#   loaded manually into ram.
#$_TARGETNAME configure -event reset-end { clear_regs }

# set a slow default JTAG clock, can be overridden later
adapter_khz 1000

# added to support memory test functionality
source [find tools/memtest.tcl]
